// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetGitConnectorCommitDetail {
    authorEmailId: string;
    authorName: string;
    message: string;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: string;
    /**
     * The name of the author
     */
    authorName?: string;
    /**
     * Commit message
     */
    message?: string;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: string;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: boolean;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: string[];
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: string;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: string;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: string[];
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: string[];
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: string[];
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: boolean;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: boolean;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: string;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: string;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The IAM role to use.
     */
    iamRole?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: outputs.InfrastructureDefinitionAwsSshTag[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: string[];
}

export interface InfrastructureDefinitionAwsSshTag {
    key: string;
    value: string;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: string;
    /**
     * Base name.
     */
    baseName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: string;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The name of the resource group.
     */
    resourceGroupName: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
    /**
     * The username to connect with.
     */
    username: string;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the resource group.
     */
    resourceGroup: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: string;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: string;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release.
     */
    releaseName: string;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The PCF organization to use.
     */
    organization: string;
    /**
     * The PCF space to deploy to.
     */
    space: string;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: number;
    /**
     * Name of the principal for authentication
     */
    principal: string;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: string;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: outputs.SshCredentialKerberosAuthenticationTgtGenerationMethod;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: string;
    keyTabFilePath?: string;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: outputs.SshCredentialSshAuthenticationInlineSsh;
    /**
     * The port to connect to
     */
    port: number;
    /**
     * Server password authentication configuration
     */
    serverPassword?: outputs.SshCredentialSshAuthenticationServerPassword;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: outputs.SshCredentialSshAuthenticationSshKeyFile;
    /**
     * The username to use when connecting to ssh
     */
    username: string;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: string;
    sshKeyFileId: string;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: string;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: string;
    path: string;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: string;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: string[];
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: string;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: boolean;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: boolean;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: string;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: string;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: string[];
    /**
     * Application specific permissions
     */
    appPermissions?: outputs.UserGroupPermissionsAppPermissions;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: outputs.UserGroupPermissionsAppPermissionsAll[];
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: outputs.UserGroupPermissionsAppPermissionsDeployment[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: outputs.UserGroupPermissionsAppPermissionsEnvironment[];
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: outputs.UserGroupPermissionsAppPermissionsPipeline[];
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: outputs.UserGroupPermissionsAppPermissionsProvisioner[];
    /**
     * Permission configuration to perform actions against services.
     */
    services?: outputs.UserGroupPermissionsAppPermissionsService[];
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: outputs.UserGroupPermissionsAppPermissionsTemplate[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: outputs.UserGroupPermissionsAppPermissionsWorkflow[];
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: string[];
    appIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: string[];
    appIds?: string[];
    provisionerIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: string[];
    appIds?: string[];
    serviceIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: string[];
    appIds?: string[];
    templateIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: string[];
    appIds?: string[];
    filters: string[];
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export namespace cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: string;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: string[];
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: outputs.cloudprovider.KubernetesAuthenticationOidc;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: outputs.cloudprovider.KubernetesAuthenticationServiceAccount;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: outputs.cloudprovider.KubernetesAuthenticationUsernamePassword;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: string;
        clientSecretSecretName?: string;
        identityProviderUrl: string;
        masterUrl: string;
        passwordSecretName: string;
        scopes?: string[];
        username: string;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: string;
        masterUrl: string;
        serviceAccountTokenSecretName: string;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: string;
        passwordSecretName: string;
        username?: string;
        usernameSecretName?: string;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

}

export namespace platform {
    export interface AppDynamicsConnectorApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: string;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret.
         */
        clientSecretRef: string;
    }

    export interface AppDynamicsConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
    }

    export interface ArtifactoryConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

    export interface AwsCCConnectorCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: string;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: string;
    }

    export interface AwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: string;
    }

    export interface AwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey?: string;
        /**
         * Reference to the Harness secret containing the aws access key.
         */
        accessKeyRef?: string;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: string[];
        /**
         * Reference to the Harness secret containing the aws secret key.
         */
        secretKeyRef: string;
    }

    export interface AwsKmsConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.platform.AwsKmsConnectorCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.platform.AwsKmsConnectorCredentialsManual;
    }

    export interface AwsKmsConnectorCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsKmsConnectorCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface AwsSecretManagerConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.platform.AwsSecretManagerConnectorCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.platform.AwsSecretManagerConnectorCredentialsManual;
    }

    export interface AwsSecretManagerConnectorCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsSecretManagerConnectorCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface BitbucketConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api.
         */
        tokenRef: string;
        /**
         * The username used for connecting to the api.
         */
        username?: string;
        /**
         * The name of the Harness secret containing the username.
         */
        usernameRef?: string;
    }

    export interface BitbucketConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.BitbucketConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.BitbucketConnectorCredentialsSsh;
    }

    export interface BitbucketConnectorCredentialsHttp {
        passwordRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface BitbucketConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface DockerConnectorCredentials {
        /**
         * The reference to the password to use for the docker registry.
         */
        passwordRef: string;
        /**
         * The username to use for the docker registry.
         */
        username?: string;
        /**
         * The reference to the username to use for the docker registry.
         */
        usernameRef?: string;
    }

    export interface GcpConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface GcpConnectorManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: string[];
        /**
         * Reference to the Harness secret containing the secret key.
         */
        secretKeyRef: string;
    }

    export interface GetAppDynamicsConnectorApiToken {
        clientId: string;
        clientSecretRef: string;
    }

    export interface GetAppDynamicsConnectorUsernamePassword {
        passwordRef: string;
        username: string;
    }

    export interface GetArtifactoryConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetAwsCCConnectorCrossAccountAccess {
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsConnectorCrossAccountAccess {
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsConnectorInheritFromDelegate {
        delegateSelectors: string[];
    }

    export interface GetAwsConnectorIrsa {
        delegateSelectors: string[];
    }

    export interface GetAwsConnectorManual {
        accessKey: string;
        accessKeyRef: string;
        delegateSelectors: string[];
        secretKeyRef: string;
    }

    export interface GetAwsKmsConnectorCredential {
        assumeRoles: outputs.platform.GetAwsKmsConnectorCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.platform.GetAwsKmsConnectorCredentialManual[];
    }

    export interface GetAwsKmsConnectorCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsKmsConnectorCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetAwsSecretManagerConnectorCredential {
        assumeRoles: outputs.platform.GetAwsSecretManagerConnectorCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.platform.GetAwsSecretManagerConnectorCredentialManual[];
    }

    export interface GetAwsSecretManagerConnectorCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsSecretManagerConnectorCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetBitbucketConnectorApiAuthentication {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketConnectorCredential {
        https: outputs.platform.GetBitbucketConnectorCredentialHttp[];
        sshes: outputs.platform.GetBitbucketConnectorCredentialSsh[];
    }

    export interface GetBitbucketConnectorCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetDockerConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGcpConnectorInheritFromDelegate {
        delegateSelectors: string[];
    }

    export interface GetGcpConnectorManual {
        delegateSelectors: string[];
        secretKeyRef: string;
    }

    export interface GetGitConnectorCredential {
        https: outputs.platform.GetGitConnectorCredentialHttp[];
        sshes: outputs.platform.GetGitConnectorCredentialSsh[];
    }

    export interface GetGitConnectorCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGithubConnectorApiAuthentication {
        githubApps: outputs.platform.GetGithubConnectorApiAuthenticationGithubApp[];
        tokenRef: string;
    }

    export interface GetGithubConnectorApiAuthenticationGithubApp {
        applicationId: string;
        installationId: string;
        privateKeyRef: string;
    }

    export interface GetGithubConnectorCredential {
        https: outputs.platform.GetGithubConnectorCredentialHttp[];
        sshes: outputs.platform.GetGithubConnectorCredentialSsh[];
    }

    export interface GetGithubConnectorCredentialHttp {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGithubConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGitlabConnectorApiAuthentication {
        tokenRef: string;
    }

    export interface GetGitlabConnectorCredential {
        https: outputs.platform.GetGitlabConnectorCredentialHttp[];
        sshes: outputs.platform.GetGitlabConnectorCredentialSsh[];
    }

    export interface GetGitlabConnectorCredentialHttp {
        passwordRef: string;
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitlabConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetHelmConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetKubernetesConnectorClientKeyCert {
        caCertRef: string;
        clientCertRef: string;
        clientKeyAlgorithm: string;
        clientKeyPassphraseRef: string;
        clientKeyRef: string;
        masterUrl: string;
    }

    export interface GetKubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface GetKubernetesConnectorOpenidConnect {
        clientIdRef: string;
        issuerUrl: string;
        masterUrl: string;
        passwordRef: string;
        scopes: string[];
        secretRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetKubernetesConnectorServiceAccount {
        masterUrl: string;
        serviceAccountTokenRef: string;
    }

    export interface GetKubernetesConnectorUsernamePassword {
        masterUrl: string;
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetNexusConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId: string;
        filter: string;
        /**
         * Unique identifier of the organization.
         */
        orgId: string;
        /**
         * Unique identifier of the project.
         */
        projectId: string;
    }

    export interface GetResourceGroupResourceFilter {
        includeAllResources: boolean;
        resources: outputs.platform.GetResourceGroupResourceFilterResource[];
    }

    export interface GetResourceGroupResourceFilterResource {
        attributeFilters: outputs.platform.GetResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers: string[];
        resourceType: string;
    }

    export interface GetResourceGroupResourceFilterResourceAttributeFilter {
        attributeName: string;
        attributeValues: string[];
    }

    export interface GetSecretSshkeyKerbero {
        principal: string;
        realm: string;
        tgtGenerationMethod: string;
        tgtKeyTabFilePathSpecs: outputs.platform.GetSecretSshkeyKerberoTgtKeyTabFilePathSpec[];
        tgtPasswordSpecs: outputs.platform.GetSecretSshkeyKerberoTgtPasswordSpec[];
    }

    export interface GetSecretSshkeyKerberoTgtKeyTabFilePathSpec {
        keyPath: string;
    }

    export interface GetSecretSshkeyKerberoTgtPasswordSpec {
        password: string;
    }

    export interface GetSecretSshkeySsh {
        credentialType: string;
        sshPasswordCredentials: outputs.platform.GetSecretSshkeySshSshPasswordCredential[];
        sshkeyPathCredentials: outputs.platform.GetSecretSshkeySshSshkeyPathCredential[];
        sshkeyReferenceCredentials: outputs.platform.GetSecretSshkeySshSshkeyReferenceCredential[];
    }

    export interface GetSecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase: string;
        keyPath: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyReferenceCredential {
        encryptedAssphrase: string;
        key: string;
        userName: string;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl: string;
        /**
         * Pager duty key
         */
        pagerDutyKey: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type: string;
    }

    export interface GitConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GitConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GitConnectorCredentialsSsh;
    }

    export interface GitConnectorCredentialsHttp {
        passwordRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GithubConnectorApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: outputs.platform.GithubConnectorApiAuthenticationGithubApp;
        /**
         * Personal access token for interacting with the github api.
         */
        tokenRef?: string;
    }

    export interface GithubConnectorApiAuthenticationGithubApp {
        applicationId: string;
        installationId: string;
        privateKeyRef: string;
    }

    export interface GithubConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GithubConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GithubConnectorCredentialsSsh;
    }

    export interface GithubConnectorCredentialsHttp {
        tokenRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GithubConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GitlabConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api.
         */
        tokenRef: string;
    }

    export interface GitlabConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GitlabConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GitlabConnectorCredentialsSsh;
    }

    export interface GitlabConnectorCredentialsHttp {
        passwordRef?: string;
        tokenRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitlabConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface HelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

    export interface KubernetesConnectorClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector.
         */
        caCertRef?: string;
        /**
         * Reference to the secret containing the client certificate for the connector.
         */
        clientCertRef: string;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: string;
        /**
         * Reference to the secret containing the client key passphrase for the connector.
         */
        clientKeyPassphraseRef?: string;
        /**
         * Reference to the secret containing the client key for the connector.
         */
        clientKeyRef: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
    }

    export interface KubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface KubernetesConnectorOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector.
         */
        clientIdRef: string;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: string;
        /**
         * Scopes to request for the connector.
         */
        scopes?: string[];
        /**
         * Reference to the secret containing the client secret for the connector.
         */
        secretRef?: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: string;
    }

    export interface KubernetesConnectorServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the service account token for the connector.
         */
        serviceAccountTokenRef: string;
    }

    export interface KubernetesConnectorUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: string;
    }

    export interface NexusConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: string;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: string;
        /**
         * Organization Identifier
         */
        orgId?: string;
        /**
         * Project Identifier
         */
        projectId?: string;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: boolean;
        /**
         * Resources for a resource group
         */
        resources?: outputs.platform.ResourceGroupResourceFilterResource[];
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: outputs.platform.ResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers?: string[];
        resourceType: string;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: string;
        attributeValues?: string[];
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: string;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: string;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: string;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: outputs.platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: outputs.platform.SecretSshkeyKerberosTgtPasswordSpec;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: string;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: string;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: string;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: outputs.platform.SecretSshkeySshSshPasswordCredential;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: outputs.platform.SecretSshkeySshSshkeyPathCredential;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: outputs.platform.SecretSshkeySshSshkeyReferenceCredential;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: string;
        keyPath: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: string;
        key?: string;
        userName: string;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key
         */
        pagerDutyKey?: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: string;
    }
}

export namespace service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

}
